### **فصل ۴: الگوی بازتاب (The Reflection Pattern)**

مدل‌های زبانی بزرگ (LLMs) در تولید پاسخ‌های سریع و منسجم شگفت‌انگیزند. با این حال، اولین خروجی آن‌ها، مانند اولین پیش‌نویس یک نویسنده، به ندرت بی‌نقص است. این مدل‌ها می‌توانند اطلاعات نادرست تولید کنند (که به آن «توهم» یا hallucination می‌گویند)، جزئیات مهم را نادیده بگیرند، یا راه‌حل‌هایی ارائه دهند که بهینه نیستند. در حالی که انسان‌ها به طور طبیعی کار خود را مرور، نقد و اصلاح می‌کنند، عامل‌های هوش مصنوعی ساده این قابلیت ذاتی را ندارند و اغلب اولین پاسخ خود را به عنوان پاسخ نهایی ارائه می‌دهند.

الگوی بازتاب (Reflection Pattern) این کاستی را با معرفی یک فرآیند ساختاریافته برای خود-اصلاحی (self-correction) برطرف می‌کند. این الگو به عامل اجازه می‌دهد تا از یک تولیدکننده ساده به یک متفکر دقیق تبدیل شود که می‌تواند خروجی‌های خود را ارزیابی کرده و آن‌ها را بهبود بخشد.

#### **مشکل (Problem)**

چگونه می‌توانیم کیفیت، دقت و قابلیت اطمینان خروجی یک عامل هوش مصنوعی را فراتر از اولین تلاش آن افزایش دهیم؟ چگونه می‌توانیم عاملی بسازیم که بتواند اشتباهات خود را شناسایی و اصلاح کند، خواه این اشتباهات واقعیت‌های نادرست، باگ‌های کد، یا عدم انطباق با نیازمندی‌های کاربر باشد؟

یک پاسخ تک‌مرحله‌ای (single-pass generation) برای وظایف پیچیده یا حساس، مانند نوشتن گزارش‌های مالی، تولید کد برای سیستم‌های تولیدی، یا ارائه مشاوره حقوقی، اغلب ناکافی و پرخطر است.

#### **راه‌حل (Solution)**

الگوی بازتاب یک حلقه بازخورد (feedback loop) را پیاده‌سازی می‌کند که در آن عامل خروجی اولیه خود را تولید می‌کند، سپس در نقشی دیگر به عنوان یک «منتقد» (critic) عمل کرده و آن خروجی را ارزیابی می‌کند و در نهایت از آن نقد برای تولید یک نسخه اصلاح‌شده و بهبودیافته استفاده می‌کند.

این فرآیند، الهام‌گرفته از نحوه تفکر و حل مسئله انسان، تولید (generation) را به یک فرآیند تکرارشونده (iterative process) تبدیل می‌کند که به طور مداوم کیفیت خروجی را افزایش می‌دهد.

#### **نحوه کارکرد (How It Works)**

پیاده‌سازی الگوی بازتاب معمولاً شامل سه مرحله اصلی است که می‌توانند چندین بار تکرار شوند:

1.  **مرحله ۱: تولید (Generate):** عامل هوش مصنوعی بر اساس درخواست اولیه کاربر، یک پاسخ یا راه‌حل اولیه تولید می‌کند. این خروجی به عنوان «پیش‌نویس اول» (first draft) در نظر گرفته می‌شود.
2.  **مرحله ۲: بازتاب (Reflect):** خروجی اولیه به همراه درخواست اصلی و مجموعه‌ای از معیارهای ارزیابی به یک مدل زبانی بزرگ (که می‌تواند همان مدل اولیه یا مدلی دیگر باشد) ارسال می‌شود. این مدل وظیفه دارد تا خروجی را نقد کند. پرامپت (prompt) برای این مرحله معمولاً شامل سوالاتی مانند این است:
    *   آیا این پاسخ به طور کامل به درخواست کاربر پرداخته است؟
    *   آیا حاوی اطلاعات نادرست یا توهم است؟
    *   آیا می‌توان آن را واضح‌تر، مختصرتر یا دقیق‌تر کرد؟
    *   (برای کد) آیا این کد کارآمد است؟ آیا موارد مرزی (edge cases) را در نظر گرفته است؟ آیا از بهترین شیوه‌ها (best practices) پیروی می‌کند؟
    خروجی این مرحله، یک نقد سازنده (constructive critique) است که نقاط ضعف و پیشنهادهایی برای بهبود را مشخص می‌کند.
3.  **مرحله ۳: اصلاح (Refine):** در نهایت، درخواست اولیه، خروجی ناقص اولیه و نقد تولید شده در مرحله بازتاب، همگی به مدل زبانی بزرگ داده می‌شوند. به مدل دستور داده می‌شود تا یک نسخه جدید و بهبودیافته از خروجی را تولید کند که به طور خاص به موارد مطرح شده در نقد پرداخته باشد.

این چرخه **تولید $\leftarrow$ بازتاب $\leftarrow$ اصلاح** می‌تواند تا زمانی که خروجی به یک استاندارد کیفی مشخص برسد یا تعداد تکرارها به یک حد معین برسد، ادامه یابد.

#### **مثال عملی: یک عامل تولیدکننده کد**

فرض کنید از یک عامل می‌خواهیم یک تابع پایتون برای بررسی اینکه آیا یک رشته «پالیندروم» (palindrome - از هر دو طرف یکسان خوانده می‌شود) است یا نه، بنویسد.

*   **مرحله ۱ (تولید):** عامل ممکن است یک راه‌حل ساده و کارآمد تولید کند:
    ```python
    def is_palindrome(s):
        return s == s[::-1]
    ```
*   **مرحله ۲ (بازتاب):** پرامپت نقد از مدل می‌پرسد: "این کد را بررسی کن. آیا موارد مرزی را در نظر می‌گیرد؟ مانند حروف بزرگ و کوچک، علائم نگارشی و فاصله‌ها؟"
    منتقد پاسخ می‌دهد: "این کد برای رشته‌های ساده کار می‌کند، اما به حروف بزرگ و کوچک حساس است (case-sensitive) و علائم نگارشی و فاصله‌ها را در نظر نمی‌گیرد. به عنوان مثال، `is_palindrome('Racecar')` مقدار `False` را برمی‌گرداند در حالی که باید `True` باشد."
*   **مرحله ۳ (اصلاح):** عامل با دریافت کد اولیه و این نقد، نسخه اصلاح‌شده زیر را تولید می‌کند:
    ```python
    import re

    def is_palindrome(s):
        # Remove non-alphanumeric characters and convert to lowercase
        normalized_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower()
        return normalized_s == normalized_s[::-1]
    ```
این نسخه جدید بسیار قوی‌تر است و به طور موثرتری مسئله را حل می‌کند.

#### **مزایا (Benefits)**

*   **افزایش کیفیت و دقت:** این الگو به طور قابل توجهی احتمال وجود خطا، توهم و اطلاعات ناقص را در خروجی نهایی کاهش می‌دهد.
*   **حل مسائل پیچیده‌تر:** با تقسیم کردن فرآیند به تولید و نقد، عامل می‌تواند مسائل چندوجهی را که نیاز به بررسی و اصلاح دارند، بهتر مدیریت کند.
*   **افزایش قابلیت اطمینان:** خروجی‌هایی که از یک فرآیند بازتاب عبور کرده‌اند، برای استفاده در کاربردهای حساس، قابل اعتمادتر هستند.

#### **ملاحظات و چالش‌ها (Considerations and Challenges)**

*   **افزایش هزینه و تأخیر (Increased Cost and Latency):** هر حلقه از این الگو نیازمند حداقل دو فراخوانی اضافی به مدل زبانی بزرگ است که هم هزینه (بر اساس توکن) و هم زمان پاسخ را افزایش می‌دهد. این الگو باید برای وظایفی استفاده شود که کیفیت در آن‌ها بر سرعت اولویت دارد.
*   **کیفیت پرامپت نقد:** اثربخشی الگوی بازتاب به شدت به کیفیت پرامپت مرحله نقد بستگی دارد. یک پرامپت نقد ضعیف یا مبهم، بازخورد مفیدی تولید نخواهد کرد.
*   **خطر بهبود نیافتن:** ممکن است عامل در یک حلقه گیر کند و نتواند خروجی خود را بهبود بخشد، به خصوص اگر نقد اولیه به اندازه کافی مشخص نباشد. تعیین یک محدودیت برای تعداد تکرارها برای جلوگیری از حلقه‌های بی‌پایان ضروری است.

در فصل بعدی، به بررسی **الگوی برنامه‌ریزی (The Planning Pattern)** خواهیم پرداخت که به عامل‌ها این امکان را می‌دهد تا وظایف پیچیده را به گام‌های کوچکتر و قابل مدیریت تقسیم کنند.
