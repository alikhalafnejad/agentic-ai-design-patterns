### **فصل ۳: الگوی موازی‌سازی (The Parallelization Pattern)**

در دنیای برنامه‌های کاربردی تعاملی، سرعت همه چیز است. کاربران انتظار پاسخ‌های سریع را دارند و هر تأخیری می‌تواند منجر به ناامیدی و کاهش تعامل شود. عامل‌های هوش مصنوعی (AI Agents)، به ویژه آن‌هایی که برای انجام وظایف خود به ابزارهای خارجی (external tools) متکی هستند، در معرض خطر تأخیر یا لتنسی (latency) بالا قرار دارند. اگر یک عامل نیاز به فراخوانی چندین API یا انجام چندین جستجو داشته باشد، اجرای این وظایف به صورت متوالی (sequentially) می‌تواند به سرعت زمان پاسخ را افزایش دهد و تجربه کاربری را مختل کند.

الگوی موازی‌سازی (Parallelization Pattern) یک راه‌حل قدرتمند برای این مشکل ارائه می‌دهد. این الگو بر یک اصل ساده اما مؤثر متمرکز است: **اگر وظایف به یکدیگر وابسته نیستند، آن‌ها را به صورت همزمان اجرا کنید، نه پشت سر هم.**

#### **مشکل (Problem)**

یک عامل هوش مصنوعی اغلب با سناریوهایی مواجه می‌شود که در آن باید چندین کار مستقل را برای رسیدن به یک هدف انجام دهد. برای مثال، ممکن است نیاز داشته باشد:

*   داده‌ها را از چندین منبع (API) مختلف جمع‌آوری کند.
*   چندین سند را به طور مستقل پردازش یا خلاصه کند.
*   چندین فرضیه یا مسیر عملیاتی ممکن را به طور همزمان ارزیابی کند.

اجرای این وظایف به صورت متوالی (sequentially) ناکارآمد است. زمان کل برابر با مجموع زمان اجرای تک تک وظایف خواهد بود. چگونه می‌توانیم یک عامل را طوری طراحی کنیم که این وظایف مستقل را به طور کارآمد اجرا کرده و زمان انتظار کلی را به حداقل برساند؟

#### **راه‌حل (Solution)**

الگوی موازی‌سازی، اجرای همزمان (concurrent execution) وظایف مستقل را پیشنهاد می‌کند. به جای منتظر ماندن برای اتمام هر کار قبل از شروع کار بعدی، عامل تمام وظایف غیروابسته را به یکباره آغاز می‌کند. سپس منتظر می‌ماند تا همه آن‌ها تکمیل شوند و پس از آن نتایج را برای پردازش بیشتر جمع‌آوری می‌کند.

این رویکرد، که گاهی اوقات به عنوان مدل "fan-out/fan-in" شناخته می‌شود، زمان کل اجرای فرآیند را به زمان طولانی‌ترین وظیفه کاهش می‌دهد، نه مجموع زمان همه وظایف.

#### **نحوه کارکرد (How It Works)**

پیاده‌سازی الگوی موازی‌سازی معمولاً شامل چهار مرحله کلیدی است:

1.  **مرحله ۱: شناسایی وظایف (Task Identification):** اولین و مهم‌ترین گام این است که مدل زبانی بزرگ (LLM) به عنوان مغز عامل، مجموعه‌ای از اقدامات مورد نیاز را شناسایی کند. مهم‌تر از آن، مدل باید تشخیص دهد که کدام یک از این اقدامات به یکدیگر وابسته نیستند و می‌توانند به صورت موازی (in parallel) اجرا شوند. فریم‌ورک‌های مدرن عامل‌ها، مانند LangChain، این قابلیت را دارند که به مدل‌های زبانی بزرگ اجازه دهند لیستی از فراخوانی‌های ابزار را به جای یک فراخوانی واحد، خروجی دهند.
2.  **مرحله ۲: اجرای موازی (Parallel Execution):** پس از شناسایی وظایف موازی، یک لایه اجرایی (execution layer) در کد، این وظایف را به صورت همزمان آغاز می‌کند. این کار معمولاً با استفاده از قابلیت‌های برنامه‌نویسی ناهمزمان (asynchronous programming) که در زبان‌های مدرن مانند پایتون (`asyncio`) یا جاوا اسکریپت (`Promise.all`) وجود دارد، انجام می‌شود. هر فراخوانی ابزار در یک نخ (thread) یا فرآیند (process) جداگانه اجرا می‌شود و به سایر وظایف اجازه می‌دهد بدون منتظر ماندن، پیش بروند.
3.  **مرحله ۳: جمع‌آوری نتایج (Result Aggregation):** سیستم منتظر می‌ماند تا تمام وظایف موازی به پایان برسند. پس از اتمام، نتایج (یا هرگونه خطا) از هر وظیفه جمع‌آوری می‌شود. این نتایج سپس در یک ساختار داده واحد (مانند یک لیست یا دیکشنری) ترکیب می‌شوند تا برای گام بعدی آماده شوند.
4.  **مرحله ۴: پردازش نهایی (Final Processing):** نتایج جمع‌آوری شده به مدل زبانی بزرگ بازگردانده می‌شود. اکنون مدل می‌تواند از این مجموعه اطلاعات جامع برای انجام مرحله بعدی استدلال خود استفاده کند، مانند خلاصه‌سازی یافته‌ها، مقایسه نتایج، یا ارائه یک پاسخ نهایی به کاربر.

#### **مثال عملی: یک عامل برنامه‌ریز سفر**

یک عامل برنامه‌ریز سفر را در نظر بگیرید که وظیفه دارد بهترین گزینه برای پرواز، هتل و ماشین کرایه‌ای را برای سفر کاربر پیدا کند.

*   **رویکرد متوالی (Sequential Approach):**
    1.  فراخوانی API پرواز (منتظر ماندن ۱۰ ثانیه).
    2.  فراخوانی API هتل (منتظر ماندن ۸ ثانیه).
    3.  فراخوانی API ماشین کرایه‌ای (منتظر ماندن ۵ ثانیه).
    *   **زمان کل: ۲۳ ثانیه.**

*   **رویکرد موازی (Parallel Approach):**
    1.  فراخوانی همزمان API پرواز، API هتل و API ماشین کرایه‌ای.
    2.  منتظر ماندن تا طولانی‌ترین فراخوانی (پرواز، ۱۰ ثانیه) به پایان برسد.
    *   **زمان کل: ۱۰ ثانیه.**

با استفاده از الگوی موازی‌سازی، عامل می‌تواند اطلاعات مورد نیاز را در کمتر از نیمی از زمان جمع‌آوری کند که منجر به تجربه کاربری بسیار سریع‌تر و پاسخ‌گوتر می‌شود.

#### **مزایا (Benefits)**

*   **کاهش چشمگیر زمان پاسخ (Drastic Latency Reduction):** این واضح‌ترین مزیت است. زمان انتظار کاربر به طور قابل توجهی کاهش می‌یابد.
*   **بهبود تجربه کاربری (Improved User Experience):** سیستم‌های سریع‌تر، رضایت‌بخش‌تر هستند و کاربران را بیشتر درگیر نگه می‌دارند.
*   **افزایش توان عملیاتی (Increased Throughput):** از آنجایی که منابع به طور کارآمدتری استفاده می‌شوند، سیستم می‌تواند در یک بازه زمانی معین، درخواست‌های بیشتری را مدیریت کند.

#### **ملاحظات و چالش‌ها (Considerations and Challenges)**

*   **مدیریت خطا (Error Handling):** چه اتفاقی می‌افتد اگر یکی از فراخوانی‌های موازی با خطا مواجه شود؟ سیستم شما باید یک استراتژی قوی برای مدیریت خطاهای جزئی داشته باشد. آیا باید کل فرآیند را متوقف کند، با نتایج موفق ادامه دهد، یا وظیفه ناموفق را دوباره امتحان کند؟
*   **محدودیت‌های نرخ API (API Rate Limits):** اجرای تعداد زیادی درخواست به صورت همزمان ممکن است شما را به محدودیت‌های نرخ (rate limits) اعمال شده توسط سرویس‌های خارجی نزدیک کند. پیاده‌سازی شما باید این محدودیت‌ها را در نظر بگیرد و شاید شامل مکانیزم‌هایی مانند `backoff` یا `throttling` باشد.
*   **وابستگی وظایف (Task Dependencies):** این الگو فقط برای وظایف واقعاً مستقل قابل اعمال است. مدل زبانی بزرگ باید به اندازه کافی هوشمند باشد تا وابستگی‌ها را درک کند (برای مثال، شما نمی‌توانید جزئیات یک رزرو هتل را دریافت کنید قبل از اینکه شناسه رزرو را داشته باشید).

در فصل بعدی، ما به سراغ یک الگوی متفاوت اما به همان اندازه مهم خواهیم رفت: **الگوی بازتاب (The Reflection Pattern)**، که به عامل‌ها توانایی خودارزیابی و بهبود را می‌دهد.