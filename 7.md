## **فصل ۶: الگوی استفاده از ابزار (The Tool Use Pattern)**

یکی از بزرگ‌ترین نقاط تمایز بین یک مدل زبانی بزرگ ساده و یک عامل هوش مصنوعی کامل، توانایی «عمل کردن» (Acting) است. مدل‌های زبانی به تنهایی فقط می‌توانند **متن تولید کنند**؛ آن‌ها نمی‌توانند اطلاعات واقعی بگیرند، محاسبات انجام دهند یا در دنیای بیرون تغییری ایجاد کنند. اما هدف نهایی طراحی عامل‌ها، ساخت سیستمی است که بتواند واقعاً کار انجام دهد — نه صرفاً پاسخ دهد.

الگوی استفاده از ابزار (Tool Use Pattern) همان جایی است که این شکاف بین «دانستن» و «انجام دادن» پر می‌شود.

---

### **مشکل (Problem)**

چگونه می‌توان یک عامل را قادر ساخت تا از محدودیت دانشی خود فراتر رود، داده‌های واقعی را بازیابی کند و کارهای عملی انجام دهد؟  
به طور پیش‌فرض، مدل‌های زبانی اطلاعات خود را از روی مجموعه‌ای از داده‌های از پیش آموزش‌دیده (Training Data) دارند. این داده‌ها دارای «تاریخ قطع دانش (Knowledge Cutoff Date)» هستند، یعنی پس از تاریخی خاص، دیگر چیزی از دنیا نمی‌دانند.

برای مثال، اگر از یک مدل در سال ۲۰۲۵ بپرسیم نرخ فعلی تورم در ایران یا Forecast قیمت شکر در برزیل چیست، پاسخ آن صرفاً تخمینی خواهد بود — نه واقعیت.  
به همین دلیل، بدون توانایی دسترسی به ابزارهای بیرونی مانند **Web Search API، پایگاه داده‌ها، یا سرویس‌های محاسباتی**، هیچ عامل هوش مصنوعی نمی‌تواند وظایف واقعی را با نتایج دقیق انجام دهد.

---

### **راه‌حل (Solution)**

راه‌حل، افزودن توانایی «استفاده از ابزارها» به عامل است.  
در این الگو، عامل، علاوه بر LLM که مغز او محسوب می‌شود، مجموعه‌ای از **ابزارها (Tools)** را در اختیار دارد — هر ابزار قابلیت خاصی را فعال می‌کند، مانند جستجو در وب، اجرای کد، یا خواندن داده از یک پایگاه اطلاعاتی.  
عامل با این ابزارها از طریق ساختارهای کنترلی خود (مثل Agent Loop یا Controller) تعامل می‌کند.

این تعامل معمولاً به‌صورت چرخه‌ای زیر اتفاق می‌افتد:

> **مشاهده (Observe)** → **تفکر (Think)** → **انتخاب ابزار (Select Tool)** → **اجرا (Act)** → **بازخورد (Observe Result)**

در واقع، عامل تصمیم می‌گیرد که برای رسیدن به هدف، کدام ابزار باید استفاده شود و سپس نتیجه آن را تحلیل می‌کند تا گام بعدی را مشخص کند.

---

### **معماری (Architecture)**

معماری معمولی این الگو ۳ بخش اصلی دارد:

1.  **LLM به عنوان مغز مرکزی**
    - مسئول فهم وظیفه، تصمیم‌گیری، و استدلال.
2.  **مجموعه ابزارها (Tool Registry)**
    - محل تعریف تمام قابلیت‌های قابل استفاده توسط عامل؛ معمولاً به‌شکل یک دیکشنری یا کلاس قابل توسعه:
    ```python
    tools = {
        "search": WebSearchTool(),
        "calculator": PythonREPLTool(),
        "database_query": SQLTool(),
        "image_analysis": VisionTool()
    }
    ```
3.  **حلقه عامل (Agent Controller)**
    - وظیفه دارد پیام‌های بین LLM و ابزارها را مدیریت کند.  
      برای هر گام تصمیم‌گیری، خروجی مدل را تحلیل می‌کند تا بفهمد کدام ابزار باید اجرا شود. سپس نتیجه را به مدل بازمی‌گرداند تا ادامه تفکر انجام شود.

---

### **مثال اجرا (Example)**

فرض کنید کاربر از عامل هوشمندش می‌خواهد:

> «می‌تونی به من بگی متوسط قیمت ذرت در یک ماه اخیر در بازار شیکاگو چقدر بوده؟ سپس یک نمودار از تغییراتش رسم کن.»

فرآیند اجرای عامل با الگوی Tool Use چنین است:

1.  **LLM تصمیم می‌گیرد از ابزار “MarketData API” استفاده کند**  
    و یک Query برای دریافت قیمت روزانه تولید می‌کند.
2.  **ابزار اجرا می‌شود و داده قیمت‌ها را برمی‌گرداند** (در قالب JSON).
3.  **LLM تصمیم می‌گیرد از ابزار “Python” یا “Matplotlib” برای رسم نمودار استفاده کند.**
4.  **خروجی نهایی** — یک تصویر همراه با خلاصه‌ای متنی از تحلیل داده به کاربر ارائه می‌شود.

در هر مرحله، LLM با توجه به نتیجه ابزار قبلی، تصمیم بعدی را اتخاذ می‌کند.

---

### **نکات طراحی (Design Principles)**

1.  **جداسازی وظایف (Separation of Concerns):**  
    مدل زبانی نباید منطق ابزار را بداند یا اجرا کند؛ تنها باید تصمیم بگیرد *کدام ابزار* لازم است.  
    ابزار باید مستقل از مدل طراحی شود تا بتوانند به راحتی جایگزین یا ارتقا یابند.

2.  **نمایش واضح ابزارها (Tool Signature Clarity):**  
    هر ابزار باید شامل توضیح مختصر عملکرد، پارامترها و قالب خروجی باشد.  
    مثال:
    ```python
    class WeatherTool:
        name = "weather"
        description = "Fetch current weather for a given location"
        parameters = {"location": "string"}
        output_format = "JSON"
    ```

3.  **مدیریت خطا (Error Handling):**  
    اگر ابزار شکست بخورد یا پاسخ نامعتبر برگرداند، عامل باید بتواند خطا را تحلیل کرده و اقدام اصلاحی (مثل retry یا انتخاب ابزار جایگزین) انجام دهد.

4.  **ایجاد حافظه کارکردی (Tool Memory):**  
    عامل باید بتواند نتایج ابزارهایی که اخیراً استفاده کرده است را به خاطر بسپارد تا از تکرار درخواست‌ها جلوگیری کند (caching).

---

### **مزایا (Benefits)**

*   **دسترسی به اطلاعات تازه و واقعی:** ابزارها مانند چشم و گوش‌های عامل در جهان بیرون هستند.
*   **گسترش قابلیت‌ها:** هر ابزار جدید، یک عملکرد تازه به موجودیت عامل اضافه می‌کند.
*   **امکان عمل‌گرایی (Actionability):** عامل از سطح زبان به سطح عمل می‌رسد — می‌تواند ایمیل ارسال کند، پایگاه داده را تغییر دهد یا حتی کد اجرا کند.
*   **پیاده‌سازی انعطاف‌پذیر:** ابزارها می‌توانند داخلی (local) یا خارجی (remote API) باشند.

---

### **چالش‌ها و ملاحظات (Challenges and Considerations)**

*   **امنیت (Security):** عامل‌های دارای دسترسی به محیط واقعی می‌توانند به داده‌های حساس یا سرویس‌های بحرانی دسترسی داشته باشند؛ باید محدودیت و sandbox وجود داشته باشد.
*   **مدیریت حالت ابزار (Tool State):** برخی ابزارها (مثل مرورگر یا session API) حالت دارند. هماهنگی بین عامل و ابزار در این مورد حیاتی است.
*   **تطبیق با زبان طبیعی:** باید بین خروجی ابزار (مثلاً JSON) و ورودی LLM (متن طبیعی) پل برقرار شود.
*   **هزینه و تأخیر:** فراخوانی ابزارها زمان‌بر است و ممکن است هزینه API ایجاد کند.  
*   **کنترل رفتار عامل:** باید guardrails داشته باشیم تا از فراخوانی خطرناک یا غیرمجاز ابزارها جلوگیری شود.

---

### **الگوی ترکیبی (Hybrid Pattern Integration)**

الگوی استفاده از ابزار معمولاً به‌صورت ترکیبی با سایر الگوهای کتاب مثل الگوی **برنامه‌ریزی (Planning)** و **بازتاب (Reflection)** استفاده می‌شود.

برای نمونه:
*   عامل ابتدا با **Planning Pattern** برای دستیابی به هدف کاربر یک نقشه گام‌به‌گام می‌سازد.
*   سپس با **Tool Use Pattern**، ابزارهای مورد نیاز هر گام را اجرا می‌کند.
*   و در انتها، با **Reflection Pattern** خروجی خود را ارزیابی و بهبود می‌دهد.

این ترکیب، اساس طراحی عامل‌های پیشرفته‌ای است که در سیستم‌های امروزی مانند **LangChain، AutoGen و Google ADK** استفاده می‌شوند.

---

### **جمع‌بندی فصل**

الگوی استفاده از ابزار، قلب هر عامل عملیاتی است.  
این الگو به او امکان می‌دهد تا از صرفاً "یک مدل گفتگو" فراتر رفته و به "یک موجود عمل‌گرا" تبدیل شود که می‌تواند با داده‌های واقعی تعامل کند و خروجی‌های معنی‌دار تولید نماید.  
در دنیای مهندسی هوش مصنوعی، قدرت عامل نه فقط در دانستن، بلکه در توانایی انجام دادن است — و این دقیقاً همان چیزی است که Tool Use Pattern محقق می‌کند.

---

در فصل بعد (فصل ۷) کتاب، وارد بررسی یکی از پیشرفته‌ترین و هوشمندترین الگوها می‌شویم: **الگوی حافظه (Memory Pattern)** — جایی که عامل یاد می‌گیرد چگونه گذشته خود را به خاطر داشته باشد، تا آینده‌اش هوشمندتر شود.